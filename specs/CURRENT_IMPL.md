# CURRENT_IMPL.md

## Snapshot

- Snapshot date: 2026-02-18
- Repository: `belzabar` (Bun/Turbo monorepo)
- Total files currently present: 115
- Apps:
1. `apps/automation-designer` (AD CLI)
2. `apps/page-designer` (PD CLI)
3. `apps/extension` (browser extension for AD/PD web UIs)
- Shared package:
1. `packages/core` (`@belzabar/core`)

This document captures what is implemented right now, including behavior, contracts, data flow, and known gaps.

## High-Level Architecture

1. Shared CLI primitives live in `packages/core`.
2. AD and PD CLIs use `@belzabar/core` for:
- environment config
- auth/session
- API fetch wrapper
- command runner
- human/LLM output rendering
3. Browser extension is separate (plain JS, Manifest V3) and manipulates live AD/PD DOM.
4. Repo has internal specs/context docs in `specs/` plus app-level docs in each app folder.

## Repository Layout

1. `package.json` (workspace root, Turbo scripts)
2. `turbo.json` (build/dev/lint pipeline)
3. `packages/core/*` (shared runtime package)
4. `apps/automation-designer/*` (command-driven AD tooling + MCP server)
5. `apps/page-designer/*` (PD analysis tooling)
6. `apps/extension/*` (content script extension)
7. `specs/AIM.md`, `specs/ROADMAP.md`, `specs/BELZABAR.md`, `specs/NSM.md` (context docs)

## Toolchain and Runtime

1. Runtime: Bun (`type: module` across apps)
2. Language:
- TypeScript for CLIs/core
- JavaScript for browser extension
3. Workspace/build:
- Root scripts use Turbo (`build`, `dev`, `lint`)
- App CLIs compile to single binaries (`belz`, `pd`) via `bun build --compile`
4. Typing/validation:
- `zod` in core config validation
5. CLI UX:
- `chalk` and `cli-table3` for human-mode output

## `@belzabar/core` (Current Contract)

### Module Surface

`packages/core/src/index.ts` exports:

1. `types`
2. `config`
3. `auth`
4. `api`
5. `display`
6. `command`
7. `output`
8. `runner`

### Environment Config

`packages/core/src/config.ts`:

1. Environments hardcoded:
- `nsm-dev` (default)
- `nsm-qa`
- `nsm-uat`
2. Supported env vars:
- `NSM_DEV_URL`, `NSM_DEV_USER`, `NSM_DEV_PASSWORD`
- `NSM_QA_URL`, `NSM_QA_USER`, `NSM_QA_PASSWORD`
- `NSM_UAT_URL`, `NSM_UAT_USER`, `NSM_UAT_PASSWORD`
- legacy fallback: `BASE_URL`, `API_USER`, `API_PASSWORD`
3. Passwords expected Base64-encoded; decoded with `atob` when accessed.
4. Active env can be switched via `Config.setActiveEnv(name)`.

### Auth + Session

`packages/core/src/auth.ts`:

1. Login endpoint: `POST <baseUrl>/do/login`
2. Session storage path:
- `~/.belzabar-cli/sessions/<env>.json`
3. Token extraction fallback order:
- JSON body `token`
- raw JWT-like body
- `Authorization` header (with or without `Bearer `)
4. Refresh token read from response header `refresh-token`.

### API Wrapper

`packages/core/src/api.ts`:

1. Adds default `Accept` + `User-Agent`.
2. Adds `Content-Type: application/json` when needed.
3. Auth modes:
- `Bearer`
- `Raw`
- `None`
4. Auto login if missing session.
5. Retries once on 401 after forced re-login.
6. Special behavior:
- if request header `Expertly-Auth-Token: "true"` exists, session token is injected into that header.

### Command Framework

`packages/core/src/command.ts` + `packages/core/src/runner.ts`:

1. Strong command envelope model (`schema`, `version`, `ok`, `command`, `data`, `error`, `meta`).
2. Global flags handled centrally:
- `--llm` (JSON envelope output)
- `--env` / `-e`
- global `--help`
3. Error normalization to stable machine-friendly shape.
4. Command modules implement:
- optional `parseArgs`
- required `execute`
- optional `presentHuman`

### Output Behavior

1. Human mode:
- default renderer infers table/object formatting
- command-level presenters can override
2. LLM mode:
- strict JSON envelope printed via `renderLLM`

## App: `automation-designer`

### Purpose

CLI to inspect/test/run Automation Designer methods via APIs.

### Entry Points and Build

1. Dev entry: `apps/automation-designer/bin/cli.ts`
- dynamic command folder loading
2. Binary entry: `apps/automation-designer/bin/cli-build.ts`
- static generated registry
3. Registry generated by: `apps/automation-designer/utils/generate-registry.ts`

### Command Set (7)

1. `envs`
2. `fetch-method`
3. `show-method`
4. `test-method`
5. `run-method`
6. `save-suite`
7. `run-suites`

### AD Libraries

1. `lib/api.ts`
- `fetchAutomationDefinition(automationId)`
- `fetchMethodDefinition(uuid)`
- `testMethod(formData)`
2. `lib/parser.ts`
- parses `jsonDefinition` string into normalized `HydratedMethod`
3. `lib/cache.ts`
- method cache in `~/.belzabar-cli/cache/methods`
- TTL: 5 minutes
4. `lib/hydrator.ts`
- service definition cache in `~/.belzabar-cli/cache/definitions`
- resolves service input/output metadata for detail view
5. `lib/input-collector.ts`
- loads inputs from JSON file or interactive prompt (`inquirer`)
6. `lib/payload-builder.ts`
- injects `testValue` fields into method `jsonDefinition`
7. `lib/error-parser.ts`
- extracts structured DB/code error details from service execution messages

### AD Command Behavior (Current)

1. `fetch-method`
- fetch chain by UUID
- parse + cache method
- pre-hydrate unique service definitions
- optional `--raw`
2. `show-method`
- reads cache first unless `--force`
- supports:
  - `--inputs`
  - `--services`
  - `--service-detail <n>`
  - `--full`
  - `--raw`
- can decode BASE64 SQL/code for full service expansion
3. `test-method`
- fetch draft method definition
- collect/inject test values
- call `/rest/api/automation/chain/test`
- return trace + failed step + parsed output
4. `run-method`
- execute published chain via `/rest/api/automation/chain/execute/<id>?encrypted=true`
- accepts payload inline JSON or file path
- auth mode: `Raw`
5. `save-suite`
- captures method inputs into `suites/<name>.spec.json`
6. `run-suites`
- executes all suite specs in local `suites/`
- marks suite pass/fail by `executionStatus.failed`
- returns `ok: false` with summary if any suite fails
7. `envs`
- lists active and available envs

### AD MCP Integration

`apps/automation-designer/integrations/gemini-mcp/server.ts`:

1. Exposes JSON-RPC tools:
- `ad.show_method`
- `ad.test_method`
2. Internally shells out to CLI with `--llm`.
3. Parses returned envelope and converts errors to JSON-RPC failures.

### AD Tests

Only unit tests currently:

1. `tests/unit/parser.test.ts`
2. `tests/unit/payload.test.ts`

No integration/e2e or CI test orchestration is implemented in repo root.

### AD Current Gaps / Mismatches

1. `test-method` parses `--force` and `--verbose`, but:
- `force` is not used in execution path
- `verbose` only changes a label in output (`verbosity`) and does not change trace depth
2. `show-method --service-detail` help says 0-indexed; implementation matches by `orderIndex` (typically step numbers from method data).
3. `save-suite` writes to `suites/` path but does not explicitly create parent directory.
4. `method_finder.MD` contains very large raw API dumps with embedded bearer token and PII-style sample data.
5. `tasks.md` still contains historical notes about `--llm`; current CLI behavior emits command envelopes in JSON when `--llm` is enabled.

## App: `page-designer`

### Purpose

CLI to inspect PD pages/components and recursively discover referenced AD method IDs.

### Entry Points and Build

1. Dev entry: `apps/page-designer/bin/pd.ts`
2. Binary entry: `apps/page-designer/bin/pd-build.ts`
3. Generated registry: `apps/page-designer/commands/registry.ts`

### Command Set (4)

1. `show-page`
2. `show-component`
3. `find-ad-methods`
4. `analyze`

### PD Libraries

1. `lib/api.ts`
- page fetch: `GET /rest/api/pagedesigner/pages/<id>`
- component ID lookup by name: `GET /rest/api/pagedesigner/pages?...&status=DRAFT`
- component config fetch: `PUT /rest/api/pagedesigner/pages/phrases/<id>` with partial update payload
2. `lib/parser.ts`
- extracts AD execute IDs from config URLs
- extracts nested component names from layout tree based on whitelist
3. `lib/analyzer.ts`
- recursive traversal with cycle detection (`visited` set)
4. `lib/reporter.ts`
- tree formatting and AD ID aggregation
5. `lib/comparator.ts`
- compliance diff against master AD ID set
6. `lib/config.ts`
- default root page IDs (`TARGET_PAGE_IDS`)

### PD Data Files

1. `components.json`: 324 whitelisted component names.
2. `master_ids.txt`: comma-separated approved AD IDs (168 total entries, 64 unique).
3. `test-all.txt`: captured sample run output/log (not executable test code).

### PD Command Behavior (Current)

1. `show-page <PAGE_ID>`
- fetch config
- parse summary
- optional `--full`, `--raw`
2. `show-component <NAME>`
- resolve component ID by name
- fetch config and summarize refs
- optional `--full`, `--raw`
3. `find-ad-methods <ID>`
- shallow mode: parse single target config
- recursive mode (`--recursive`): full component traversal through whitelist
- `--component` treats input as component name
4. `analyze [PAGE_ID]`
- analyze one page or all default targets
- emits dependency tree + unique AD IDs
- optional `--compliance` against `master_ids.txt`

### PD Current Gaps / Mismatches

1. `README.md` still contains generic Bun init instructions (`bun run index.ts`) not matching actual CLI entrypoints.
2. Component config retrieval uses a `PUT` endpoint with update payload; behavior is currently relied upon as read-like retrieval but endpoint semantics are unusual.
3. AD ID extraction regex expects alphanumeric-only IDs in execute URL path.

## App: `extension`

### Purpose

Browser extension content script for AD/PD pages:

1. Page title updater
2. Keyboard shortcut for Run Test
3. JSON modal editor for bulk input editing and syncing into AD form UI

### Runtime Surface

1. Manifest: `apps/extension/manifest.json` (MV3)
2. Content script target URLs:
- `nsm-dev`, `nsm-qa`, `nsm-uat`
- both `/automation-designer/*` and `/ui-designer/*`
3. Build output:
- bundles `src/content-script.js` to `dist/content-script.js`

### Feature Modules

1. Title updater (`features/title-updater/*`)
- sets title to `AD: <method>` or `PD: <page>`
2. Keyboard shortcut (`features/keyboard/shortcuts.js`)
- `Ctrl + Shift + Enter` triggers run test button click
3. Run test (`features/run-test/*`)
- finds visible enabled `exp-button` variants and clicks nested button
4. JSON editor (`features/json-editor/*`)
- injects `ðŸ“‹ JSON` button near Inputs section
- modal supports load/refresh/sync
- extraction heuristics parse input key/type/mandatory/value from AD DOM
- sync includes type normalization for:
  - Text/Number/Integer/Boolean/Date/DateTime/Json/Array/Map/StructuredData
- has special handling for:
  - `exp-select` booleans
  - datepicker widgets with calendar navigation and model syncing
  - structured-data textareas

### Extension Current Gaps / Risks

1. DOM-coupled selectors and traversal are highly implementation-specific to current AD UI.
2. Core entry (`content-script.js`) logs to console unconditionally.
3. A large amount of inline style/UI code lives in JS, increasing maintenance cost.
4. Current working tree already contains a local modification in `apps/extension/src/features/json-editor/sync.js` (implementation is in flux).

## Existing Context Docs

Current docs that describe intent and domain context:

1. `specs/AIM.md` (architecture charter and constraints)
2. `specs/ROADMAP.md` (capability-gated rolling-release roadmap)
3. `specs/BELZABAR.md` (Belzabar/NSM domain and environment workflow)
4. `specs/NSM.md` (staff vs portal origin rule and query semantics)
5. `apps/automation-designer/BELZABAR_AD_AGENT.md` (AD agent contract)
6. `apps/automation-designer/AGENTS.md` (AD architecture notes)

## Current Status Summary

1. Shared CLI foundation (`@belzabar/core`) is in place and reused by AD/PD CLIs.
2. AD CLI is the most complete app (fetch/inspect/test/run/suites + MCP shim).
3. PD CLI is focused on recursive dependency analysis and compliance reporting, driven by local whitelists.
4. Browser extension is feature-rich but DOM-fragile and maintenance-heavy.
5. Test coverage is minimal and concentrated only on two AD parsing utilities.
6. Some docs remain forward-looking versus implementation status (especially broader agent integrations).

## Quick Runbook (Current)

1. Install deps at root:
- `bun install`
2. AD CLI dev usage:
- `bun run apps/automation-designer/bin/cli.ts <command> ...`
3. PD CLI dev usage:
- `bun run apps/page-designer/bin/pd.ts <command> ...`
4. Build binaries:
- AD: run app-local `build` script to produce `belz`
- PD: run app-local `build` script to produce `pd`
5. Extension:
- `bun run build` inside `apps/extension`, then load unpacked extension.
